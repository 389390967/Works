<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>正则扩展</title>
    <link rel="shortcut icon" href="../../../img/ico.ico">
    <link rel="stylesheet" href="../../../css/common.css">
</head>

<body>
    <ul class="note">
        <li>声明</li>
        <li>
        <pre>
    	{
    	    // es5声明方法
            <i>let</i> reg = new RegExp('xyz', 'i'); // 第一个参数是正则表达式字符串，第二个是修饰符
            <i>let</i> reg2 = new RegExp(/xyz/i); // 第一个参数是正则表达式，不接受第二个参数，否则会报错

            // es6声明方法
            <i>let</i> reg3 = new RegExp(/abc/ig, 'i');
            console.log(reg3.flags); // 原有正则对象的修饰符是ig，它会被第二个参数i覆盖。flags是es6新增加的属性，用来获取正则表达式的修饰符
            输出：<em>i</em>
    	}
		</pre>
        </li>
    </ul>

    <ul class="note">
    	<li>u修饰符</li>
    	<li>u修饰符，含义为 <span>"Unicode模式"</span>，用来正确处理<span>大于 \uFFFF</span> 的Unicode字符。也就是说，会正确处理四个字符的 UTF-16 编码。</li>
    	<li>
    	<pre>
    	console.log(/^\uD83D/.test('\uD83D\uDC2A'));
    	console.log(/^\uD83D/u.test('\uD83D\uDC2A'));
    	输出：<em>true</em>
    	输出：<em>false</em>

    	上面代码中，<span>\uD83D\uDC2A</span> 是一个四字节的 UTF-16 编码，代表一个字符，
    	但是，ES5不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第一行代码结果为 true，
    	加了u修饰符以后，ES6就会识别其为一个字符，所以第二行代码结果为false。
    	</pre>
    	</li>
    </ul>

    <ul class="note">
        <li>y修饰符与g修饰符的区别</li>
        <li>
        <p>g、y都是表示全局匹配，y表示<span>粘连模式</span>（如下例：在 'aaaa_aaa_aa_a' 匹配成功 'aaaa' 后必须粘连着 'aaaa' 从它后面的'_'开始匹配）</p>
        <pre>
    	{
    	    <i>let</i> str = 'aaaa_aaa_aa_a';
    	    <i>var</i> regY = /a+/y;
    	    <i>var</i> regG = /a+/g;

    	    // y修饰符
    	    console.log(regY.exec(str), regY.lastIndex);
    	    console.log(regY.exec(str), regY.lastIndex);
    	    console.log(regY.exec(str), regY.lastIndex);
    	    console.log(regY.exec(str), regY.lastIndex);
    	    console.log(regY.exec(str), regY.lastIndex);
    	    输出：<em>["aaaa" 4]</em>
    	    输出：<em>[null 0]</em> // 当 exec() 再也找不到匹配的文本时，<span>它将返回 null，并把 lastIndex 属性重置为 0</span>
    	    输出：<em>["aaaa" 4]</em>
    	    输出：<em>[null 0]</em>
    	    输出：<em>["aaaa" 4]</em>

    	    // g修饰符
    	    console.log(regG.exec(str), regG.lastIndex);
    	    console.log(regG.exec(str), regG.lastIndex);
    	    console.log(regG.exec(str), regG.lastIndex);
    	    console.log(regG.exec(str), regG.lastIndex);
    	    console.log(regG.exec(str), regG.lastIndex);
    	    输出：<em>["aaaa" 4]</em>
    	    输出：<em>["aaa" 8]</em>
    	    输出：<em>["aa" 11]</em>
    	    输出：<em>["a" 13]</em>
    	    输出：<em>[null 0]</em>

    	    console.log(regY.sticky, regG.sticky); //表示是否开启了粘连模式
    	    输出：<em>true false</em>
    	}
    	</pre>
        </li>
    </ul>

    <ul class="note">
        <li>exec()方法</li>
        <li>
            1、如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。
        </li>
        <li>
            2、除了数组元素和 length 属性之外，exec() 方法还返回两个属性。<br>
            index 属性声明的是匹配文本的第一个字符的位置。<br>
            input 属性则存放的是被检索的字符串。
        </li>
        <li>
            3、在调用<span>非全局</span>的<span>正则表达</span>的 exec() 方法时，返回的数组与调用方法 <span>String.match()</span> 返回的数组是相同的。
        </li>
        <li>
        <pre>
        {
           // 非全局
           <i>var</i> str = "E Ethan Ethan Ethan Ethan Ethan";
           <i>var</i> reg = new RegExp("Ethan");

           console.log(str.match(reg));
           console.log(reg.exec(str));
           输出：<em>["Ethan"]</em>
           输出：<em>["Ethan"]</em> 
        }
        </pre>
        </li>
        <li>
            4、但是，当<span>正则表达式</span>是一个<span>全局</span>正则表达式式时，exec() 的行为就稍微复杂一些。<br>
            它会在<span>正则表达式</span>的 lastIndex 属性指定的字符处开始检索字符串。<br>
            当 exec() 找到了与<span>正则表达式</span>相匹配的文本时，在匹配后，它将把<span>正则表达式</span>的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。<br>
            这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。<br>
            当 exec() 再也找不到匹配的文本时，<span>它将返回 null，并把 lastIndex 属性重置为 0</span>。
        </li>
        <li>
        <pre>
        {
           // 全局
           <i>var</i> str = "E Ethan Ethan Ethan Ethan Ethan";
           <i>var</i> reg = new RegExp("Ethan","g");

           console.log(str.match(reg));
           输出：<em>["Ethan", "Ethan", "Ethan", "Ethan", "Ethan"]</em>

           <i>var</i> result;
           <i>var</i> arr = [];
           while ((result = reg.exec(str)) != null) {
           arr.push(result[0]);
           console.log('lastIndex:' + reg.lastIndex);
           }
           console.log(arr)

           输出：<em>lastIndex:7</em>
           输出：<em>lastIndex:13</em>
           输出：<em>lastIndex:19</em>
           输出：<em>lastIndex:25</em>
           输出：<em>lastIndex:31</em>
           输出：<em>["Ethan", "Ethan", "Ethan", "Ethan", "Ethan"]</em>
        }
        </pre>
        </li>
        <li>
            <em>重要事项</em>：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须<span>手动地把 lastIndex 属性重置为 0</span>。
        </li>
        <li>
            <em>提示</em>：请注意，无论<span>正则表达</span>是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。这就是 exec() 与 String.match() 的不同之处，后者在全局模式下返回的信息要少得多。因此我们可以这么说，在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法。
        </li>
    </ul>
    <script>
    {
        // es6声明方法
        let reg3 = new RegExp(/abc/ig, 'i');
        console.log(reg3.flags); // 原有正则对象的修饰符是ig，它会被第二个参数i覆盖。flags是es6新增加的属性，用来获取正则表达式的修饰符
        console.log('---------分割线---------');
    }

    {
    	console.log(/^\uD83D/.test('\uD83D\uDC2A')); // true
    	console.log(/^\uD83D/u.test('\uD83D\uDC2A')); // false
    	console.log('---------分割线---------');
    }

    {
        // 大括号表示Unicode字符，只有加上u才能识别
        console.log(/\u{61}/.test('a')); // false
        console.log(/\u{61}/u.test('a')); // true
        console.log(/\u{20BB7}/u.test('𠮷')); // true
        console.log('---------分割线---------');

        // 点（.）字符不能识别码点大于0xFFFF的Unicode字符，必须加上u修饰符。
        let s = '𠮷';
        console.log('大于0xFFFF的Unicode字符', /^.$/.test(s)); // false
        console.log('使用u字符', /^.$/u.test(s)); // true
        console.log('---------分割线---------');

        // 使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。
        console.log('量词', /a{2}/.test('aa')); // true
        console.log('量词', /a{2}/u.test('aa')); // true
        console.log('量词', /𠮷{2}/.test('𠮷𠮷')); // false
        console.log('量词', /𠮷{2}/u.test('𠮷𠮷')); // true
        console.log('---------分割线---------');
    }

    {
        // #正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外
        // U+000A 换行符（\n）
        // U+000D 回车符（\r）
        // U+2028 行分隔符（line separator）
        // U+2029 段分隔符（paragraph separator）
        // 只是一个提案目前还不支持
        // let reg=/test.go/s;
        // console.log(reg.test('test\ngo'));
        // console.log(reg.test('test\ngo'));
        console.log('s变通方法', /foo.bar/.test('foo\nbar'));
        console.log('s变通方法', /foo[^]bar/.test('foo\nbar'));
        console.log('---------分割线---------');
    }

    {
        // y修饰符与g修饰符的区别
        let str = 'aaaa_aaa_aa_a';
        var regY = /a+/y;
        var regG = /a+/g;

        console.log(regY.exec(str), regY.lastIndex);
        console.log(regY.exec(str), regY.lastIndex);
        console.log(regY.exec(str), regY.lastIndex);
        console.log(regY.exec(str), regY.lastIndex);
        console.log(regY.exec(str), regY.lastIndex);
        console.log('---------分割线---------');
        console.log(regG.exec(str), regG.lastIndex);
        console.log(regG.exec(str), regG.lastIndex);
        console.log(regG.exec(str), regG.lastIndex);
        console.log(regG.exec(str), regG.lastIndex);
        console.log(regG.exec(str), regG.lastIndex);
        console.log('---------分割线---------');

        console.log(regY.sticky,regG.sticky); //表示是否开启了粘连模式
        console.log('---------分割线---------');
    }

    // 在调用非全局的正则表达的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的
    { // 非全局
        var str = "E Ethan Ethan Ethan Ethan Ethan";
        var reg = new RegExp("Ethan");

        console.log(str.match(reg))
        console.log(reg.exec(str))
        console.log('---------分割线---------');
    } {
        // 全局
        var str = "E Ethan Ethan Ethan Ethan Ethan";
        var reg = new RegExp("Ethan", "g");

        console.log(str.match(reg))
        console.log('---------分割线---------');

        var result;
        var arr = [];
        while ((result = reg.exec(str)) != null) {
            arr.push(result[0]);
            console.log('lastIndex:' + reg.lastIndex);
        }
        console.log('---------分割线---------');
        console.log(arr)
    }
    </script>
</body>

</html>