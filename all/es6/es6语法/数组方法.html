<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>ES6数组方法扩展</title>
    <link rel="shortcut icon" href="../../../img/ico.ico">
    <link rel="stylesheet" href="../../../css/common.css">
</head>

<body>
    <h1>ES6数组方法扩展</h1>
    <ul class="note">
    	<li>总结</li>
    	<li>1、扩展运算符（...）</li>
    	<li>2、Array.form() Array.of()</li>
    	<li>3、copyWithin()</li>
    	<li>4、find()</li>
    	<li>5、fill()</li>
    	<li>6、entries() values() keys()</li>
    	<li>7、includes()</li>
    </ul>
    <ul class="note">
        <li>一、...：扩展运算符</li>
        <li>1、合并数组</li>
        <li><pre>
    	{
    	    <i>var</i> arr1 = [1, 2, 3],
    	        arr2 = [4, 5, 6];

    	    //ES5
    	    <i>console</i>.<i>log</i>(arr1.<i>concat</i>(arr2));
    	    输出：<em>[1, 2, 3, 4, 5, 6]</em>

    	    //ES6 ...
    	    <i>console</i>.<i>log</i>([...arr1, ...arr2]);
    	    输出：<em>[1, 2, 3, 4, 5, 6]</em>
    	}
        </pre>
        </li>
        <li>2、与结构赋值结合使用</li>
        <li><pre>
    	{
    	    <i>let</i> [frist, ...rest] = [1, 2, 3, 4, 5];
    	    <i>console</i>.<i>log</i>(frist);
    	    输出：<em>1</em>

    	    <i>console</i>.<i>log</i>(rest)
    	    输出：<em>[2, 3, 4, 5]</em>

    	    <i>let</i> [start, ...ends] = [<b>'Ethan'</b>];
    	    <i>console</i>.<i>log</i>(start);
    	    输出：<em>Ethan</em>

    	    <i>console</i>.<i>log</i>(ends);
    	    输出：<em>[]</em>

    	    <i>let</i> [one, ...two] = [];
    	    <i>console</i>.<i>log</i>(one);
    	    输出：<em>undefined</em>

    	    <i>console</i>.<i>log</i>(two);
    	    输出：<em>[]</em>
    	}
    	<em>注意：...xxx，后面不能再接参数</em>
        </pre>
        </li>
        <li>3、函数返回值：在函数返回多个值时，如返回数组或对象，使用扩展运算符可以解决</li>
        <li><pre>
        {
            <i>let</i> dateArr = [2019, 1, 1];//模拟函数返回的值
            <i>console</i>.<i>log</i>(...dateArr);
            输出：<em>2019 1 1</em>

            <i>let</i> date = <strong>new</strong> Date(...dateArr);
            <i>console</i>.<i>log</i>(date);
            输出：<em>Fri Feb 01 2019 00:00:00 GMT+0800 (中国标准时间)</em>
        }
        </pre>
        </li>
        <li>4、展开字符串</li>
        <li><pre>
        {
            <i>let</i> ethan = [...<b>'Ethan'</b>];
            <i>console</i>.<i>log</i>(ethan);	
            输出：<em>["E", "t", "h", "a", "n"]</em>
        }
        </pre>
        </li>
        <li>5、具有 Iterator（迭代器） 接口的对象：如类数组、 Set 和 Map 数据结构等，都可以通过扩展运算符转化为真正的数组，那些没有 Iterator 接口的数据结构，是不能使用扩展运算符转为数组的。</li>
        <li><pre>
        {
            <i>var</i> nodeList = document.querySelectorAll(<b>'li'</b>);
            <i>var</i> arrList = [...nodeList];
            <i>console</i>.<i>log</i>(arrList);
            输出：<em>[li, li, li, li, li, li, li, li, li, li, li]</em>

            <i>let</i> map = <strong>new</strong> Map([
                [<b>"name"</b>, <b>"Tom"</b>],
                [<b>"type"</b>, <b>"cat"</b>]
            ]);
            <i>console</i>.<i>log</i>([...map.entries()]);
            输出：<em>[['name', 'Tom'],['type', 'cat']]</em>
        }
        </pre>
        </li>
    </ul>
    <ul class="note">
        <li>二、数组方法扩展 </li>
        <li>1、Array.from()<br>
            <p class="padding-left-25">
                1、解析：从一个<span>类似数组</span>或者<span>可迭代对象</span>中创建一个<span>新的数组</span>实例，<br>
                这里的类似数组指：拥有 length 属性和若干索引属性的任意对象，<br>
                可迭代对象指：可以获取元素中的对象，如 Map 和 Set 等。<br>
                2、用法：<i>Array.from</i>(<em>arrayLike</em>, <em>mapFn</em>, <em>thisArg</em>);<br>
                <em>arrayLike</em>：要转化成数组的目标对象（类似数组或者可迭代对象）；<br>
                <em>mapFn</em>：可选参数，新数组中的每个元素都会调这个回调函数，类似数组中的map 方法；<br>
                <em>thisArg</em>：可选参数，执行回调函数 mapFn 的 this 对象。
            </p>
        </li>
        <li><pre>
            {
                <span>1、字符串转数组</span>
                <i>console</i>.<i>log</i>(<i>Array.from</i>(<b>"yuan"</b>));
                输出：<em>["y", "u", "a", "n"]</em>

                <span>2、Set 对象转数组</span>
                <i>let</i> str = <strong>new</strong> Set([<b>"yuan"</b>, <b>"monkey"</b>]);
                <i>console</i>.<i>log</i>(<i>Array.from</i>(str));
                输出：<em>["yuan", "monkey"]</em>

                <span>3、Map 对象转数组</span>
                <i>let</i> map = <strong>new</strong> Map([
                    [1, 2],
                    [2, 4],
                    [4, 8]
                ]);
                <i>console</i>.<i>log</i>(<i>Array.from</i>(map));
                输出：<em>[[1, 2], [2, 4], [4, 8]]</em>

                <span>4、arguments 类数组对象转数组</span>
                function arg() {
                    <strong>return</strong> <i>Array.from</i>(arguments);
                }
                <i>console</i>.<i>log</i>(arg(2, 3, 4));
                输出：<em>[2, 3, 4]</em>

                <span>5、启用第二个参数</span>
                <i>let</i> a = [1, 2, 3];
               <i>console</i>.<i>log</i>( <i>Array.from</i>(a, (x) => x * x));
               输出：<em>[1, 4, 9]</em>

                <span>6、与 length 的关系</span>
                <i>console</i>.<i>log</i>(<i>Array.from</i>({ length: 5 }, (v, i) => i * i));
                输出：<em>[0, 1, 4, 9, 16]</em>
            }
        </pre>
        </li>
        <li>2、Array.of()<br>
            <p class="padding-left-25">
                1、解析：将一组值转化为数组，这一组值的个数为任意个数。<br>
                2、用法：<i>Array.of</i>(<em>el1</em>, <em>el2</em>, ..., <em>elN</em>),elN: 指任意个参数。<br>
                3、与Array() 的区别：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。
            </p>
        </li>
        <li><pre>
        {
        	<i>console</i>.<i>log</i>(<i>Array.of</i>(7)); 
        	输出：<em>[7] </em>

        	<i>console</i>.<i>log</i>(<i>Array.of</i>(1, 2, 3)); 
        	输出：<em>[1, 2, 3]</em>


        	<i>console</i>.<i>log</i>(<i>Array</i>(7)); 
        	输出：<em>[ , , , , , , ]</em>

        	<i>console</i>.<i>log</i>(<i>Array</i>(1, 2, 3)); 
        	输出：<em>[1, 2, 3]</em>
        }
        </pre>
        </li>
        <li>3、copyWithin()<br>
            <p class="padding-left-25">
                1、解析：复制数组的一部分到同一数组的另一个位置，返回的是修改后的数组，不会修改数组的大小。<br>
                2、用法：arr.<i>copyWithin</i>(target, start, end);<br>
                <em>target</em>（必选）：目标索引，指从该位置开始替换数据。若为负数，则从末尾开始算起；<br>
                <em>start</em>（可选）：开始复制元素的起始位置，默认为0，若为负数，则从末尾开始算起；<br>
                <em>end</em>（可选）：开始复制元素的结束位置，默认为数组的长度，若为负数，则从末尾开始算起。
            </p>
        </li>
        <li><pre>
        {
            <i>console</i>.<i>log</i>([1, 2, 3, 4, 5].<i>copyWithin</i>(-2));
            输出：<em> [1, 2, 3, 1, 2]</em>

            <i>console</i>.<i>log</i>([1, 2, 3, 4, 5].<i>copyWithin</i>(0, 3));
            输出：<em> [4, 5, 3, 4, 5]</em>

            <i>console</i>.<i>log</i>([1, 2, 3, 4, 5].<i>copyWithin</i>(0, 3, 4));
            输出：<em> [4, 2, 3, 4, 5]</em>

            <i>console</i>.<i>log</i>([1, 2, 3, 4, 5].<i>copyWithin</i>(-2, -3, -1));
            输出：<em> [1, 2, 3, 3, 4]</em>

            <i>console</i>.<i>log</i>([].<i>copyWithin</i>.<i>call</i>({ length: 5, 3: 1 }, 0, 3));
            输出：<em> {0: 1, 3: 1, length: 5}</em>

            var i32a = <strong>new</strong> Int32Array([1, 2, 3, 4, 5]);
            <i>console</i>.<i>log</i>(i32a.<i>copyWithin</i>(0, 2));
            输出：<em> Int32Array [3, 4, 5, 4, 5]</em>

            兼容写法
            <i>console</i>.<i>log</i>([].<i>copyWithin</i>.<i>call</i>(<strong>new</strong> Int32Array([1, 2, 3, 4, 5]), 0, 3, 4));
            输出：<em> Int32Array [4, 2, 3, 4, 5]</em>
        }
        </pre>
        </li>
        <li>4、find() 和 findIndex()<br>
            <p class="padding-left-25">
                1、解析：找出并返回第一个符合条件的数组成员。<br>
                2、用法：arr.<i>find</i>(callback[item, index, array, thisArg]);<br>
                calback：数组的每个元素都执行这个回调函数，且这个回调函数包含参数分别是：<br>
                <em>item</em>：当前的值；<br>
                <em>index</em>：数组当前元素的位置；<br>
                <em>array</em>：数组本身。<br>
                <em>thisArg</em>（可选）：指定 callback 的 this。
            </p>
        </li>
        <li><pre>
        {
            <span>1、用对象的属性查找数组中的对象</span>
            <i>var</i> inventory = [
                { name: 'apples', quantity: 2 },
                { name: 'bananas', quantity: 0 },
                { name: 'cherries', quantity: 5 }
            ];

            <i>function</i> findCherries(fruit) {
                <strong>return</strong> fruit.name === 'cherries';
            }

            <i>var</i> result = inventory.<i>find</i>(findCherries);
            <i>console</i>.<i>log</i>(result);
            输出：<em>{ name: 'cherries', quantity: 5 }</em>

            <span>2、寻找数组中的质数</span>
            <i>function</i> isPrime(item, index, array) {
                <i>var</i> start = 2;
                <i>while</i> (start <= <i>Math</i>.<i>sqrt</i>(item)) {
                    <i>if</i> (item % start++ < 1) {
                        <strong>return</strong> false;
                    }
                }
                <strong>return</strong> item > 1;
            }

            <i>console</i>.<i>log</i>([4, 6, 8, 12].<i>find</i>(isPrime));
            输出：<em>undefined</em>

            <i>console</i>.<i>log</i>([4, 5, 8, 12].<i>find</i>(isPrime));
            输出：<em>5</em>
        }
        </pre>
        </li>
        <li>5、fill()
            <p class="padding-left-25">
                1、解析：填充数组；<br>
                2、用法：arr.<i>fill</i>(value, start, end)；<br>
                <em>value</em>：要填充的值；<br>
                <em>start</em>：填充的起始位置，默认为0；<br>
                <em>end</em>：填充结束位置，默认数组的长度。
            </p>
        </li>
        <li><pre>
        { 
            <i>console</i>.<i>log</i>([1, 2, 3].fill(4));
            输出：<em>[4, 4, 4]</em>
 
            <i>console</i>.<i>log</i>([1, 2, 3].fill(4, 1));
            输出：<em>[1, 4, 4]</em>
 
            <i>console</i>.<i>log</i>([1, 2, 3].fill(4, 1, 2));
            输出：<em>[1, 4, 3]</em>
 
            <i>console</i>.<i>log</i>([1, 2, 3, 4].fill(4, 1, 3));
            输出：<em>[1, 4, 4, 4]</em>
 
            <i>console</i>.<i>log</i>([1, 2, 3].fill(4, 1, 1));
            输出：<em>[1, 2, 3]</em>
 
            <i>console</i>.<i>log</i>([1, 2, 3].fill(4, -3, -2));
            输出：<em>[4, 2, 3]</em>
 
            <i>console</i>.<i>log</i>([1, 2, 3].fill(4, NaN, NaN));
            输出：<em>[1, 2, 3]</em>
 
            <i>console</i>.<i>log</i>(Array(3).fill(4));
            输出：<em>[4, 4, 4]</em>

            <i>console</i>.<i>log</i>([].fill.call({ length: 3 }, 4));
            输出：<em>{0: 4, 1: 4, 2: 4, length: 3}</em>
        }
        </pre>
        </li>
        <li>6、entries()、values()、keys()：用于遍历数组。它们都返回一个遍历器对象，可以用 for...of 循环进行遍历。
            <p class="padding-left-25">
                1、<i>entries</i>() 是对键值对的遍历，<br>
                2、<i>values</i>() 是对键值的遍历，<br>
                3、<i>keys</i>() 是对键名的遍历。
            </p>
        </li>
        <li><pre>
        {
            <span>1、键值对的遍历</span>
            <i>var</i> arr = ["y", "u", "a", "n"];
            <i>var</i> iterator = arr.<i>entries</i>();
            for (<i>let</i> item of iterator) {
                <i>console</i>.<i>log</i>(item);
            }
            输出：<em>[0, "y"]</em>
            输出：<em>[1, "u"]</em>
            输出：<em>[2, "a"]</em>
            输出：<em>[3, "n"]</em>

            <span>2、键值的遍历</span>
            <i>var</i> arr = ["y", "u", "a", "n"];
            <i>var</i> iterator = arr.<i>values</i>();
            for (<i>let</i> item of iterator) {
                <i>console</i>.<i>log</i>(item);
            }
            输出：<em>y</em>
            输出：<em>u</em>
            输出：<em>a</em>
            输出：<em>n</em>

            <span>3、键名的遍历</span>
            <i>var</i> arr = ["y", "u", "a", "n"];
            <i>var</i> iterator = arr.<i>keys</i>();
            for (<i>let</i> item of iterator) {
                <i>console</i>.<i>log</i>(item);
            }
            输出：<em>0</em>
            输出：<em>1</em>
            输出：<em>2</em>
            输出：<em>3</em>
        }
        </pre>
        </li>
        <li>5、includes()：
            <p class="padding-left-25">
                1、解析：判断数组是否包含某个特定的值，返回的是布尔值<br>
                2、用法：arr.<i>includes</i>(value, fromIndex)<br>
                <em>value</em>：需要查找的值<br>
                <em>fromIndex</em>：查找开始的位置，若为负值，查找开始的位置为数组的长度length + 这个负值fromIndex，默认为0。
            </p>
        </li>
        <li><pre>
        {
            <i>var</i> arr = ["y", "u", "a", "n"];
            <i>console</i>.<i>log</i>(arr.<i>includes</i>("y"));
            输出：<em>true</em> 

            <i>console</i>.<i>log</i>(arr.<i>includes</i>("z"));
            输出：<em>false</em>
        }
        </pre>
        </li>
    </ul>
    <a class="fixed-right-bottom" href="https://www.jianshu.com/p/6299fb081b06" target="_blank">参考博文</a>
    <script>
    //1、合并数组
    {
        var arr1 = [1, 2, 3],
            arr2 = [4, 5, 6];

        //ES5
        console.log(arr1.concat(arr2));

        //ES6 ...
        console.log([...arr1, ...arr2]);
    }
    console.log('----------分割线----------');

    //2、与结构赋值结合使用
    {
        let [frist, ...rest] = [1, 2, 3, 4, 5];
        console.log(frist);
        console.log(rest)

        let [start, ...ends] = ['Ethan'];
        console.log(start);
        console.log(ends);

        let [one, ...two] = [];
        console.log(one);
        console.log(two);
    }
    console.log('----------分割线----------');

    //3、函数返回值
    {
        let dateArr = [2019, 1, 1];
        console.log(...dateArr);
        let date = new Date(...dateArr);
        console.log(date);
    }
    console.log('----------分割线----------');


    //4、展开字符串
    {
        let ethan = [...'Ethan'];
        console.log(ethan);
    }
    console.log('----------分割线----------');

    //5、具有 Iterator（迭代器） 接口的对象：如类数组、 Set 和 Map 数据结构等，都可以通过扩展运算符转化为真正的数组，那些没有 Iterator 接口的数据结构，是不能使用扩展运算符转为数组的。
    {
        var nodeList = document.querySelectorAll('li');
        var arrList = [...nodeList];
        console.log(arrList);

        let map = new Map([
            ["name", "Tom"],
            ["type", "cat"]
        ]);
        console.log([...map.entries()]);
    }
    console.log('----------分割线----------');

    /*--
    二、数组方法扩展
	1、Array.from()
	从一个类似数组或者可迭代对象中创建一个新的数组实例。
	这里的类似数组指：拥有 length 属性和若干索引属性的任意对象。
	可迭代对象指：可以获取元素中的对象，如Map 和Set 等。

	使用方式：Array.from(arrayLike, mapFn, thisArg);
	三个参数代表如下：
	arrayLike：要转化成数组的目标对象（类似数组或者可迭代对象）；
	mapFn：可选参数，新数组中的每个元素都会调这个回调函数，类似数组中的map 方法；
	thisArg：可选参数，执行回调函数 mapFn 的 this 对象。
	--*/
    {
        // 1、字符串转数组
        console.log(Array.from("yuan"));

        // 2、Set 对象转数组
        let str = new Set(["yuan", "monkey"]);
        console.log(Array.from(str));

        // 3、Map 对象转数组
        let map = new Map([
            [1, 2],
            [2, 4],
            [4, 8]
        ]);
        console.log(Array.from(map));


        // 4、arguments 类数组对象转数组
        function arg() {
            return Array.from(arguments);
        }
        console.log(arg(2, 3, 4));

        // 5、启用第二个参数
        let a = [1, 2, 3];
        console.log(Array.from(a, (x) => x * x));

        // 6、与 length 的关系
        console.log(Array.from({ length: 5 }, (v, i) => i * i));
    }
    console.log('----------分割线----------');

    /*--
    2、Array.of()
    解析：将一组值转化为数组，这一组值的个数为任意个数。
    用法：Array.of(el1, el2, ..., elN);
    elN: 指任意个参数；
    与Array() 的区别：
    --*/
    {
        console.log(Array.of(7)); // [7] 
        console.log(Array.of(1, 2, 3)); // [1, 2, 3]

        console.log(Array(7)); // [ , , , , , , ]
        console.log(Array(1, 2, 3)); // [1, 2, 3]
    }
    console.log('----------分割线----------');

    /*--
    3、copyWithin()
    解析：复制数组的一部分到同一数组的另一个位置，返回的是修改后的数组，不会修改数组的大小。
    用法：arr.copyWithin(target, start, end);
    target（必选）：目标索引，指从该位置开始替换数据。若为负数，则从末尾开始算起。
    start（可选）：开始复制元素的起始位置，默认为0，若为负数，则从末尾开始算起。
    end（可选）：开始复制元素的结束位置，默认为数组的长度，若为负数，则从末尾开始算起。
    --*/
    {
        console.log([1, 2, 3, 4, 5].copyWithin(-2));
        // [1, 2, 3, 1, 2]

        console.log([1, 2, 3, 4, 5].copyWithin(0, 3));
        // [4, 5, 3, 4, 5]

        console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4));
        // [4, 2, 3, 4, 5]

        console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1));
        // [1, 2, 3, 3, 4]

        console.log([].copyWithin.call({ length: 5, 3: 1 }, 0, 3));
        // {0: 1, 3: 1, length: 5}

        var i32a = new Int32Array([1, 2, 3, 4, 5]);
        console.log(i32a.copyWithin(0, 2));
        // Int32Array [3, 4, 5, 4, 5]

        // 兼容写法
        console.log([].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4));
        // Int32Array [4, 2, 3, 4, 5]
    }
    console.log('----------分割线----------');


    /*--
    4、find() 和 findIndex()
    解析：找出并返回第一个符合条件的数组成员。
    用法：arr.find(callback[item, index, array, thisArg])
    calback：数组的每个元素都执行这个回调函数，且这个回调函数包含参数分别是：
    item：当前的值；
    index：数组当前元素的位置；
    array：数组本身。
    thisArg（可选）：指定 callback 的 this。
    --*/
    {
        // 用对象的属性查找数组中的对象
        var inventory = [
            { name: 'apples', quantity: 2 },
            { name: 'bananas', quantity: 0 },
            { name: 'cherries', quantity: 5 }
        ];

        function findCherries(fruit) {
            return fruit.name === 'cherries';
        }

        var result = inventory.find(findCherries);
        console.log(result); // { name: 'cherries', quantity: 5 }

        // 寻找数组中的质数
        function isPrime(item, index, array) {
            var start = 2;
            while (start <= Math.sqrt(item)) {
                if (item % start++ < 1) {
                    return false;
                }
            }
            return item > 1;
        }

        console.log([4, 6, 8, 12].find(isPrime)); // undefined, not found
        console.log([4, 5, 8, 12].find(isPrime)); // 5
    }
    console.log('----------分割线----------');

    /*--
    5、fill()
    解析：填充数组；
    用法：arr.fill(value, start, end)；
    value：要填充的值；
    start：填充的起始位置，填充不包括第一个位置，默认为0；
    end：填充结束位置，填充包括最后一个位置，默认数组的长度。
    --*/
    {
        console.log([1, 2, 3].fill(4)); // [4, 4, 4]
        console.log([1, 2, 3].fill(4, 1)); // [1, 4, 4]
        console.log([1, 2, 3].fill(4, 1, 2)); // [1, 4, 3] 
        console.log([1, 2, 3, 4].fill(4, 1, 3)); // [1, 4, 4, 4]
        console.log([1, 2, 3].fill(4, 1, 1)); // [1, 2, 3]
        console.log([1, 2, 3].fill(4, -3, -2)); // [4, 2, 3]
        console.log([1, 2, 3].fill(4, NaN, NaN)); // [1, 2, 3]
        console.log(Array(3).fill(4)); // [4, 4, 4]
        console.log([].fill.call({ length: 3 }, 4)) // {0: 4, 1: 4, 2: 4, length: 3}
    }
    console.log('----------分割线----------');


    /*--
    6、entries()、values()、keys()：用于遍历数组。它们都返回一个遍历器对象，可以用 for...of 循环进行遍历。
    1、entries() 是对键值对的遍历，
    2、values() 是对键值的遍历，
    3、keys() 是对键名的遍历。
    --*/
    {
        // 1、entries()
        var arr = ["y", "u", "a", "n"];
        var iterator = arr.entries();
        for (let item of iterator) {
            console.log(item);
        }
        // [0, "y"]
        // [1, "u"]
        // [2, "a"]
        // [3, "n"]

        // 2、values()
        // var arr = ["y", "u", "a", "n"];
        // var iterator = arr.values();
        // for (let item of iterator) {
        //     console.log(item);
        // }
        // y
        // u
        // a 
        // n

        // keys()
        var arr = ["y", "u", "a", "n"];
        var iterator = arr.keys();
        for (let item of iterator) {
            console.log(item);
        }
        // 0
        // 1
        // 2
        // 3
    }
    console.log('----------分割线----------');


    /*--
    5、includes()：
    1、解析：判断数组是否包含某个特定的值，返回的是布尔值
    2、用法：arr.includes(value, fromIndex)
    value：需要查找的值
    fromIndex：查找开始的位置，若为负值，查找开始的位置为数组的长度length + 这个负值fromIndex，默认为0。
    --*/
    {
        var arr = ["y", "u", "a", "n"];
        console.log(arr.includes("y"));
        // true 

        console.log(arr.includes("z"));
        // false
    }
    </script>
</body>

</html>